<!DOCTYPE html>
<html lang="id">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Minimal Grand Piano - Balanced Audio</title>
    <style>
        :root {
            --bg-color: #0f0f0f;
            --piano-bg: #000000;
            --accent: #d4af37;
            --base-width: 55px; /* Lebar base tuts putih */
            --scale: 1; /* Skala zoom */
        }

        * {
            box-sizing: border-box;
            user-select: none;
            -webkit-user-select: none;
            touch-action: none;
        }

        body {
            margin: 0;
            padding: 0;
            background-color: var(--bg-color);
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            height: 100vh;
            font-family: 'Segoe UI', sans-serif;
            overflow: hidden;
        }

        /* Container utama piano */
        .piano-wrapper {
            width: 100%;
            height: auto;
            min-height: 60vh;
            background: var(--piano-bg);
            padding: 40px 0;
            display: flex;
            justify-content: center;
            align-items: flex-start;
            overflow-x: auto;
            overflow-y: visible;
            border-bottom: 5px solid #1a1a1a;
        }

        .piano-keys {
            position: relative;
            display: flex;
            height: calc(var(--base-width) * 10);
            padding: 0 20px;
            width: fit-content;
            margin: 0 auto;
            transform-origin: top center;
            transform: scale(var(--scale));
        }

        /* Tuts Putih */
        .key.white {
            width: var(--base-width);
            height: 100%;
            background: linear-gradient(to bottom, #fff 0%, #eee 90%, #ccc 100%);
            border: 1px solid #bbb;
            border-radius: 0 0 4px 4px;
            margin: 0;
            position: relative;
            z-index: 1;
            cursor: pointer;
            box-shadow: inset 0 2px 0 #fff;
        }

        .key.white.active {
            background: linear-gradient(to bottom, #ddd 0%, #bbb 100%);
            transform: translateY(calc(var(--base-width) * 0.036));
        }

        /* Tuts Hitam */
        .key.black {
            width: calc(var(--base-width) * 0.65);
            height: 60%;
            background: linear-gradient(to bottom, #444 0%, #000 100%);
            border: 1px solid #000;
            border-radius: 0 0 3px 3px;
            position: absolute;
            z-index: 2;
            top: 0;
            box-shadow: calc(var(--base-width) * 0.036) calc(var(--base-width) * 0.072) calc(var(--base-width) * 0.109) rgba(0,0,0,0.5);
            cursor: pointer;
        }

        .key.black.active {
            background: linear-gradient(to bottom, #222 0%, #111 100%);
            height: calc(60% - calc(var(--base-width) * 0.036));
        }

        /* Label tuts (proporsional) */
        .key-label {
            position: absolute;
            bottom: calc(var(--base-width) * 0.18);
            left: 50%;
            transform: translateX(-50%);
            font-size: calc(var(--base-width) * 0.18);
            color: rgba(0,0,0,0.2);
            font-weight: bold;
            pointer-events: none;
        }

        /* Panel Kontrol Zoom & Volume */
        .controls {
            padding: 20px;
            display: flex;
            align-items: center;
            justify-content: center;
            flex-wrap: wrap;
            gap: 30px;
            color: #aaa;
            font-size: 0.9rem;
        }

        input[type=range] {
            appearance: none;
            width: 200px;
            height: 4px;
            background: #333;
            border-radius: 5px;
            outline: none;
        }

        input[type=range]::-webkit-slider-thumb {
            appearance: none;
            width: 15px;
            height: 15px;
            background: var(--accent);
            border-radius: 50%;
            cursor: pointer;
        }

        /* Overlay Awal */
        #overlay {
            position: fixed;
            top: 0; left: 0; width: 100%; height: 100%;
            background: #000;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            z-index: 100;
            transition: opacity 0.5s;
        }

        #overlay button {
            padding: 15px 35px;
            background: none;
            border: 1px solid var(--accent);
            color: var(--accent);
            font-size: 1rem;
            cursor: pointer;
            letter-spacing: 2px;
            transition: all 0.3s;
        }

        #overlay button:hover {
            background: var(--accent);
            color: #000;
        }
    </style>
</head>
<body>

    <div id="overlay">
        <button id="start-btn">MULAI PIANO</button>
    </div>

    <div class="piano-wrapper">
        <div class="piano-keys" id="board"></div>
    </div>

    <div class="controls">
        <span>-</span>
        <input type="range" id="zoomSlider" min="20" max="100" value="55">
        <span>+</span>

        <span>Vol</span>
        <input type="range" id="volumeSlider" min="0" max="200" value="100">
        <span id="volumeValue">100%</span>
    </div>

<script>
    const notesFreq = {
        "C3": 130.81, "C#3": 138.59, "D3": 146.83, "D#3": 155.56, "E3": 164.81, "F3": 174.61, "F#3": 185.00, "G3": 196.00, "G#3": 207.65, "A3": 220.00, "A#3": 233.08, "B3": 246.94,
        "C4": 261.63, "C#4": 277.18, "D4": 293.66, "D#4": 311.13, "E4": 329.63, "F4": 349.23, "F#4": 369.99, "G4": 392.00, "G#4": 415.30, "A4": 440.00, "A#4": 466.16, "B4": 493.88,
        "C5": 523.25, "C#5": 554.37, "D5": 587.33, "D#5": 622.25, "E5": 659.25, "F5": 698.46, "F#5": 739.99, "G5": 783.99, "G#5": 830.61, "A5": 880.00, "A#5": 932.33, "B5": 987.77,
        "C6": 1046.50
    };

    const keyMap = [
        { note: "C3",  type: "white", key: "q" }, { note: "C#3", type: "black", key: "2" },
        { note: "D3",  type: "white", key: "w" }, { note: "D#3", type: "black", key: "3" },
        { note: "E3",  type: "white", key: "e" }, { note: "F3",  type: "white", key: "r" },
        { note: "F#3", type: "black", key: "5" }, { note: "G3",  type: "white", key: "t" },
        { note: "G#3", type: "black", key: "6" }, { note: "A3",  type: "white", key: "y" },
        { note: "A#3", type: "black", key: "7" }, { note: "B3",  type: "white", key: "u" },
        { note: "C4",  type: "white", key: "i" }, { note: "C#4", type: "black", key: "9" },
        { note: "D4",  type: "white", key: "o" }, { note: "D#4", type: "black", key: "0" },
        { note: "E4",  type: "white", key: "p" }, { note: "F4",  type: "white", key: "z" },
        { note: "F#4", type: "black", key: "s" }, { note: "G4",  type: "white", key: "x" },
        { note: "G#4", type: "black", key: "d" }, { note: "A4",  type: "white", key: "c" },
        { note: "A#4", type: "black", key: "f" }, { note: "B4",  type: "white", key: "v" },
        { note: "C5",  type: "white", key: "b" }, { note: "C#5", type: "black", key: "h" },
        { note: "D5",  type: "white", key: "n" }, { note: "D#5", type: "black", key: "j" },
        { note: "E5",  type: "white", key: "m" }, { note: "F5",  type: "white", key: "," },
        { note: "F#5", type: "black", key: "l" }, { note: "G5",  type: "white", key: "." },
        { note: "G#5", type: "black", key: ";" }, { note: "A5",  type: "white", key: "/" },
        { note: "B5",  type: "white", key: "'" }
    ];

    let audioCtx;
    let compressor;
    let masterGain;
    const activeVoices = {};

    function initAudio() {
        if (!audioCtx) audioCtx = new (window.AudioContext || window.webkitAudioContext)();
        if (audioCtx.state === 'suspended') audioCtx.resume();

        if (!compressor) {
            compressor = audioCtx.createDynamicsCompressor();
            compressor.threshold.setValueAtTime(-30, audioCtx.currentTime);
            compressor.knee.setValueAtTime(30, audioCtx.currentTime);
            compressor.ratio.setValueAtTime(20, audioCtx.currentTime);
            compressor.attack.setValueAtTime(0.003, audioCtx.currentTime);
            compressor.release.setValueAtTime(0.25, audioCtx.currentTime);
            compressor.connect(audioCtx.destination);
        }

        if (!masterGain) {
            masterGain = audioCtx.createGain();
            masterGain.gain.value = 1.0;
            if (compressor) {
                compressor.disconnect();
                compressor.connect(masterGain);
            }
            masterGain.connect(audioCtx.destination);
        }
    }

    function playGrandPiano(note) {
        if (!audioCtx) initAudio();
        const freq = notesFreq[note];
        if (!freq) return;

        const now = audioCtx.currentTime;

        if (activeVoices[note]) {
            const old = activeVoices[note];
            old.mainGain.gain.cancelScheduledValues(now);
            old.mainGain.gain.setValueAtTime(old.mainGain.gain.value || 0, now);
            old.mainGain.gain.linearRampToValueAtTime(0.001, now + 0.1);
            old.oscillators.forEach(osc => {
                try { osc.stop(now + 0.11); } catch (e) {}
            });
        }

        const mainGain = audioCtx.createGain();
        mainGain.connect(compressor || audioCtx.destination);
        const duration = 3.5;

        const baseVolume = 0.5;
        const freqCompensation = Math.min(3, Math.max(1, 400 / freq));
        const targetGain = baseVolume * freqCompensation;

        mainGain.gain.setValueAtTime(0, now);
        mainGain.gain.linearRampToValueAtTime(targetGain, now + 0.01);
        mainGain.gain.exponentialRampToValueAtTime(0.001, now + duration);

        const partials = [
            { f: 1, g: 0.35, t: 'sine', detune: -10 },
            { f: 1, g: 0.35, t: 'sine', detune: 10 },
            { f: 2, g: 0.20, t: 'sine' },
            { f: 3, g: 0.15, t: 'triangle' },
            { f: 4, g: 0.10, t: 'sine' },
            { f: 5, g: 0.05, t: 'triangle' }
        ];

        const oscillators = [];

        partials.forEach(p => {
            const osc = audioCtx.createOscillator();
            osc.type = p.t;
            osc.frequency.setValueAtTime(freq * p.f, now);
            if (p.detune !== undefined) osc.detune.setValueAtTime(p.detune, now);

            const g = audioCtx.createGain();
            g.gain.setValueAtTime(p.g, now);

            osc.connect(g);
            g.connect(mainGain);
            osc.start(now);
            osc.stop(now + duration + 0.2);

            oscillators.push(osc);
        });

        activeVoices[note] = { mainGain, oscillators };
    }

    const board = document.getElementById('board');
    const zoomSlider = document.getElementById('zoomSlider');
    const volumeSlider = document.getElementById('volumeSlider');
    const volumeValue = document.getElementById('volumeValue');
    const keyElements = {};

    keyMap.forEach((item) => {
        const div = document.createElement('div');
        div.className = `key ${item.type}`;
        div.dataset.note = item.note;
        div.dataset.key = item.key;
        div.innerHTML = `<span class="key-label">${item.key.toUpperCase()}</span>`;
        board.appendChild(div);
        keyElements[item.key] = div;
    });

    function positionBlackKeys() {
        Array.from(board.children).forEach(key => {
            if (key.classList.contains('black')) {
                const prevWhite = key.previousElementSibling;
                if (prevWhite && prevWhite.classList.contains('white')) {
                    const whiteWidth = prevWhite.offsetWidth;
                    const whiteLeft = prevWhite.offsetLeft;
                    key.style.left = `${whiteLeft + whiteWidth - key.offsetWidth / 2}px`;
                }
            }
        });
    }

    // Posisi black keys hanya sekali (base layout), scaling akan handle proporsi secara sempurna
    positionBlackKeys();
    window.addEventListener('load', positionBlackKeys);
    window.addEventListener('resize', positionBlackKeys);

    // Zoom dengan transform scale (tidak perlu update posisi black keys lagi)
    zoomSlider.addEventListener('input', (e) => {
        const scale = e.target.value / 55;
        document.documentElement.style.setProperty('--scale', scale);
    });

    volumeSlider.addEventListener('input', (e) => {
        const vol = e.target.value / 100;
        if (masterGain) masterGain.gain.value = vol;
        volumeValue.textContent = Math.round(vol * 100) + '%';
    });

    function triggerStart(keyChar) {
        const el = keyElements[keyChar];
        if (!el) return;
        el.classList.add('active');
        playGrandPiano(el.dataset.note);
    }

    function triggerEnd(keyChar) {
        const el = keyElements[keyChar];
        if (el) el.classList.remove('active');
    }

    window.addEventListener('keydown', (e) => { if(!e.repeat) triggerStart(e.key.toLowerCase()); });
    window.addEventListener('keyup', (e) => { triggerEnd(e.key.toLowerCase()); });

    const touchMap = {};
    board.addEventListener('touchstart', (e) => {
        e.preventDefault();
        initAudio();
        Array.from(e.changedTouches).forEach(t => {
            const el = document.elementFromPoint(t.clientX, t.clientY)?.closest('.key');
            if (el) {
                const k = el.dataset.key;
                touchMap[t.identifier] = k;
                triggerStart(k);
            }
        });
    }, {passive:false});

    board.addEventListener('touchend', (e) => {
        Array.from(e.changedTouches).forEach(t => {
            if (touchMap[t.identifier]) {
                triggerEnd(touchMap[t.identifier]);
                delete touchMap[t.identifier];
            }
        });
    });

    board.addEventListener('touchmove', (e) => {
        Array.from(e.changedTouches).forEach(t => {
            const el = document.elementFromPoint(t.clientX, t.clientY)?.closest('.key');
            const oldK = touchMap[t.identifier];
            if (el && el.dataset.key !== oldK) {
                if (oldK) triggerEnd(oldK);
                const newK = el.dataset.key;
                triggerStart(newK);
                touchMap[t.identifier] = newK;
            }
        });
    });

    let mouseDown = false;
    let currentMouseKey = null;

    board.addEventListener('mousedown', (e) => {
        if (e.button !== 0) return;
        initAudio();
        mouseDown = true;
        const el = e.target.closest('.key');
        if (el) {
            const k = el.dataset.key;
            currentMouseKey = k;
            triggerStart(k);
        }
    });

    board.addEventListener('mousemove', (e) => {
        if (!mouseDown) return;
        const el = document.elementFromPoint(e.clientX, e.clientY)?.closest('.key');
        if (el) {
            const newK = el.dataset.key;
            if (newK !== currentMouseKey) {
                if (currentMouseKey) triggerEnd(currentMouseKey);
                triggerStart(newK);
                currentMouseKey = newK;
            }
        } else {
            if (currentMouseKey) {
                triggerEnd(currentMouseKey);
                currentMouseKey = null;
            }
        }
    });

    board.addEventListener('mouseup', (e) => {
        if (e.button !== 0) return;
        mouseDown = false;
        if (currentMouseKey) {
            triggerEnd(currentMouseKey);
            currentMouseKey = null;
        }
    });

    board.addEventListener('mouseleave', () => {
        if (mouseDown) {
            mouseDown = false;
            if (currentMouseKey) {
                triggerEnd(currentMouseKey);
                currentMouseKey = null;
            }
        }
    });

    document.getElementById('start-btn').addEventListener('click', () => {
        initAudio();
        const initialVol = volumeSlider.value / 100;
        if (masterGain) masterGain.gain.value = initialVol;
        volumeValue.textContent = Math.round(initialVol * 100) + '%';

        document.getElementById('overlay').style.opacity = '0';
        setTimeout(() => {
            document.getElementById('overlay').style.display = 'none';
            positionBlackKeys();
        }, 500);
    });

</script>
</body>
</html>
